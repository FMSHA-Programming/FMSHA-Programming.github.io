---
layout: page
title: Конспекты уроков
date: 2021-12-31
---

# dd mm 2021

## Кодирование текстовых данных

В памяти компьютера хранятся только биты информации - последовательность из нулей и единиц. Последовательность бит естественным образом можно использовать для хранения чисел (в двоичном представлении). Но как хранить тексты, которые представлены последовательностью *символов*? Решение состоит в том, чтобы каждый символ представить *кодом* - последовательностью битов.

### Кодировка ASCII

American standard code for information interchange (ASCII) - таблица кодировки симполов, разработанная в 1963 году. ASCII кодирует каждый симпол с помощью семи бит и включает:

* десятичные цифры
* латинский алфавит
* знаки препинания
* управляющие символы

Таблица ASCII показана ниже. Здесь строка показывает значение трех старших битов, а столбцы - четырех младших.

![ASCII](ASCII_Code_Chart.svg.png)

Язык Си [использует кодировку ASCII](https://en.cppreference.com/w/cpp/language/ascii) для кодирования символов (`char` занимает 8 бит, старший бит не участвует в кодировании).

Кодировка ASCII удобна тем, что буквы латинского алфавита распологаются последовательно: прописные быквы от `A` до `Z` представлены в диапазоне от `41` до `5a` (шестандцатеричная система), а строчные буквы от `a` до `z` - в диапазоне от `61` до `7a`.

ASCII - довольно ограниченная система кодирования символов и не отвечает современным требованиям передачи данных в сети. В настоящее время стандарт [Unicode](https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4) используется гораздо шире. Этот стандарт позволяет кодировать знаки почти всех письменных языков мира. Строки в языке Python закодированы с помощью Unicode. За такую универсальностью приходится платить памятью - размер символа в Unicode лежит в диапазоне от одного до четырех байт.

## Префиксный код

Таблица ASCII кодирует каждый символ одинаковым количеством битов. Это позволяет легко кодировать и декодировать данные. Давайте зададимся целью сделать код, занимающий наименьшее место в памяти. 

Ни одно из кодовых значений не является префиксом другого кодового значения. В этом случае гарантируется однозначное декодирование данных.

### Префиксное дерево

Префиксный код можно представить в виде дерева.

Задача: построить оптимальное префиксное дерево для данного распределения частоты использования символов.

### Код Хаффмана

Пусть алфавит содержит `n` символов, `n > 2`. Каждому символу `a_i` соответствует частота появления `f_i`, пусть `f_i != f_j` для любых `i != j`.

Определим для префиксного дерева `T` величину `v(T)`:

```c
v(T) = alpha_0 * f_0 + alpha_1 * f_1 + ... + alpha_{n-1} * f_{n-1}
```

Здесь `alpha_i` обозначает количество бит, которые используются для кодирования символа `a_i`.

Пусть `a_k` и `a_l` - два элемента с наименьшими частотами. Тогда для префиксного дерева Хаффмана выполняются условия:

1. Имеют наибольшую глубину
2. Имеют общего родителя


Построение префиксного дерева Хаффмана:

1. Находим два символа с наименьшими частотами и делаем из них узлы дерева с общим родителем.
2. Объединяем эти два элемента в новый элемент. Частота нового элемента равна сумме частот элементов.
3. Повторяем процедуру, начиная с шага 1 до тех пор пока не останется один элемент.

Код Хаффмана гарантирует оптимальность кодирования (т.е. наименьшее значение величины `v(T)` для данного набора символов и значений их частот).

**Пример**. Кодирование последовательности ДНК.
