---
layout: page
title: Конспекты уроков
date: 2021-12-31
---

# dd mm 2021

## Кодирование текстовых данных

В памяти компьютера хранятся только биты информации - последовательность из нулей и единиц. Последовательность бит естественным образом можно использовать для хранения чисел (в двоичном представлении). Но как хранить тексты, которые представлены последовательностью *символов*? Ответ в том, чтобы каждый символ представить в памяти в виде числа.

### Кодировка ASCII


## Префиксный код

Ни одно из кодовых значений не является префиксом другого кодового значения. В этом случае гарантируется однозначное декодирование данных.

### Префиксное дерево

Префиксный код можно представить в виде дерева.

Задача: построить оптимальное префиксное дерево для данного распределения частоты использования символов.

### Код Хаффмана

Пусть алфавит содержит `n` символов, `n > 2`. Каждому символу `a_i` соответствует частота появления `f_i`, пусть `f_i != f_j` для любых `i != j`.

Определим для префиксного дерева `T` величину `v(T)`:

```c
v(T) = alpha_0 * f_0 + alpha_1 * f_1 + ... + alpha_{n-1} * f_{n-1}
```

Здесь `alpha_i` обозначает количество бит, которые используются для кодирования символа `a_i`.

Пусть `a_k` и `a_l` - два элемента с наименьшими частотами. Тогда для префиксного дерева Хаффмана выполняются условия:

1. Имеют наибольшую глубину
2. Имеют общего родителя


Построение префиксного дерева Хаффмана:

1. Находим два символа с наименьшими частотами и делаем из них узлы дерева с общим родителем.
2. Объединяем эти два элемента в новый элемент. Частота нового элемента равна сумме частот элементов.
3. Повторяем процедуру, начиная с шага 1 до тех пор пока не останется один элемент.

Код Хаффмана гарантирует оптимальность кодирования (т.е. наименьшее значение величины `v(T)` для данного набора символов и значений их частот).

**Пример**. Кодирование последовательности ДНК.






## Измерение времени

При написании программ бывает полезно измерять время работы отдельных частей кода. Инструменты для измерения есть в стандартной библиотеке `time.h`:

```c
#include <time.h>

clock_t start = clock();
// Do something
clock_t end = clock();
float seconds = (float)(end - start) / CLOCKS_PER_SEC;
```

## Псевдослучайные числа

Функция `rand` из стандартной библиотеки `stdlib.h` позволяет генерировать псевдостучайные целые числа от `0` до `RAND_MAX`. Функция `srand` позволяет выбрать последовательность псевдостучайных чисел. Для данного агрумента `srand` функция `rand` будет выдавать одну и ту же последовательность:

```c
#include <stdlib.h>

srand(10);
int r = rand();
```

**Упражение 3**. Заполните массив из `100000` значений случайными числами и измерьте время сортировки этого массива с помощью алгоритма сортировки вставками.

## Работа с файлами

### Чтение данных из файла

Функция `fopen` из библиотеки `stdio.h` позволяет открыть файл. Пусть у нас есть файл `data.txt` следующего содержания:

```bash
6
5
8
5
3
1
4
```

Прочитаем первое число из этого файла:

```c
FILE* fptr = fopen("data.txt", "r");
if (fptr == NULL) {
    puts("Can't open file");
    return 1;
}

int n;
fscanf(fptr, "%d", &n);
printf("%d\n", n);
```

Первый вргумент функции `fopen` - путь до файла, второй аргумент может принимать значения:

- `"r"` - открытие файла для чтения
- `"w"` - открытие файла для записи (если файл существует, он будет переписан)
- `"a"` - открытие файла для записи в конец существующего файла (append)

Если добавить символ `b`, то работа с файлом будет происходить в бинарном (а не в текстовом) режиме (например, `"rb"` означает чтение бинарных данных).

Функция `fopen` возвращает указатель на структуру `FILE`. Эта структура содержит всю необходимую информацию для дальнейшей работы с файлом. Если файл не удалось открыть, то `fopen` возвращает `NULL`. Всегда проверяйте открылся успешно ли открылся файл.

Функция `fscanf` является аналогом функции `scanf` для работы с файлами. Единственное отличие состоит в том, что первым аргументом необходимо передать указатель `FILE*`.

Другие функции для чтения символов из файла:

- `fgetc` читает один символ:

  ```c
  FILE* fptr = fopen("data.txt", "r");
  char ch = fgetc(fptr);
  ```

  `fgetc` возвращает константу `EOF` в случае, если достигнут конец файла.
- `getline` читает файл до символа переноса строки или до достижения ограничения по размеру или до достижения конца файла:

  ```c
  FILE* fptr = fopen("data.txt", "r");
  char s[100];
  getline(s, 100, fptr);
  ```

После завершения работы с файлом, его необходимо закрыть. Для этого необходимо вызвать функцию `fclose`.

Функция `feof` позволяет узнать достигнут ли конец файла. Используя эту функцию, прочитаем файл `data.txt` полностью. Вот полный код программы:

```c
#include <stdio.h>

int main() {
    FILE* fptr = fopen("data.txt", "r");
    if (fptr == NULL) {
        puts("Can't open file");
        return 1;
    }

    int n;
    while (!feof(fptr)) {
        fscanf(fptr, "%d", &n);
        printf("%d ", n);
    }
    putchar('\n');
    fclose(fptr);

    return 0;
}
```

В результате выполнения программы получим:

```bash
6 5 8 5 3 1 4 4 
```

### Запись данных в файл

Для записи данных в файл существуют функции, аналогичные функциям вывода в стандарный поток:

- `fprintf` отличается от `printf` тем, что первым аргументом принимает указатель `FILE*`.
- `fputc` записывает символ в файл.

Сгенерируем последовательность случайных чисел от `0` до `1` и запишем их в файл:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE* fptr = fopen("random.txt", "w");
    if (fptr == NULL) {
        puts("Can't create file\n");
        return 1;
    }

    for (int i = 0; i < 1000; ++i) {
        double x = (double)rand() / RAND_MAX;
        fprintf(fptr, "%.3lf\n", x);
    }

    fclose(fptr);

    return 0;
}
```
